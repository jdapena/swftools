--- xpdf/CharCodeToUnicode.cc.orig	2012-06-11 09:11:40.000000000 +0200
+++ xpdf/CharCodeToUnicode.cc	2012-06-11 09:48:58.000000000 +0200
@@ -395,7 +395,13 @@
     if (code >= mapLen) {
       mapLen = (code + 256) & ~255;
     }
+    Unicode *oldmap = map;
     map = (Unicode *)greallocn(map, mapLen, sizeof(Unicode));
+    if (!map) {
+      /* we sometimes get overflows for files trying to use 0xffffffff as charcode */
+      map = oldmap;
+      return;
+    }
     for (i = oldLen; i < mapLen; ++i) {
       map[i] = 0;
     }
--- xpdf/FoFiTrueType.cc.orig	2012-06-11 14:22:22.000000000 +0200
+++ xpdf/FoFiTrueType.cc	2012-06-11 14:24:48.000000000 +0200
@@ -2074,7 +2074,11 @@
       } else {
 	pos = getU16BE(tables[i].offset + j*2, &parsedOk);
       }
-      if (pos < 0 || pos > len) {
+      if (pos > len) {
+        nGlyphs = j;
+        break;
+      }
+      if (pos < 0) {
 	parsedOk = gFalse;
       }
     }
--- xpdf/Function.cc.orig	2012-06-11 14:22:22.000000000 +0200
+++ xpdf/Function.cc	2012-06-11 14:22:22.000000000 +0200
@@ -463,7 +463,8 @@
 
     // pull 2^m values out of the sample array
     for (j = 0; j < (1<<m); ++j) {
-      sBuf[j] = samples[idx0 + idxOffset[j] + i];
+      int idx = idx0 + idxOffset[j] + i;
+      sBuf[j] = (idx >= 0 && idx < nSamples) ? samples[idx] : 0;
     }
 
     // do m sets of interpolations
--- xpdf/gfile.cc.orig	2012-06-11 14:25:35.000000000 +0200
+++ xpdf/gfile.cc	2012-06-11 14:33:29.000000000 +0200
@@ -440,6 +440,53 @@
 #endif
 }
 
+static char* getTempDir()
+{
+#ifdef WIN32
+  char *dir = getenv("TMP");
+  if (!dir) dir = getenv("TEMP");
+  if (!dir) dir = getenv("tmp");
+  if (!dir) dir = getenv("temp");
+  if (!dir) dir = "C:\\";
+#else
+  char *dir = getenv("SWFTOOLS_TMP");
+  if (!dir) dir = "/tmp/";
+#endif
+  return dir;
+}
+
+char* mktmpname(char*ptr) {
+  static char tmpbuf[128];
+  char *dir = getTempDir();
+  int l = strlen(dir);
+  char *sep = "";
+  if (!ptr)
+    ptr = tmpbuf;
+  if (l && dir[l - 1] != '/' && dir[l - 1] != '\\') {
+#ifdef WIN32
+    sep = "\\";
+#else
+    sep = "/";
+#endif
+  }
+
+  //   used to be mktemp. This does remove the warnings, but
+  //   It's not exactly an improvement.
+#ifdef HAVE_LRAND48
+  sprintf(ptr, "%s%s%08x%08x",dir,sep,(unsigned int)lrand48(),(unsigned int)lrand48());
+#else
+#   ifdef HAVE_RAND
+  sprintf(ptr, "%s%s%08x%08x",dir,sep,rand(),rand());
+#   else
+  static int count = 1;
+  sprintf(ptr, "%s%s%08x%04x%04x",dir,sep,time(0),(unsigned int)tmpbuf^((unsigned int)tmpbuf)>>16,count);
+  count ++;
+#   endif
+#endif
+  return ptr;
+}
+
+
 GBool openTempFile(GString **name, FILE **f, const char *mode, char *ext) {
 #if defined(WIN32)
   //---------- Win32 ----------
@@ -451,7 +498,7 @@
   // this has the standard race condition problem, but I haven't found
   // a better way to generate temp file names with extensions on
   // Windows
-  if ((tempDir = getenv("TEMP"))) {
+  if ((tempDir = getenv("SWFTOOLS_TMP"))) {
     s = new GString(tempDir);
     s->append('\\');
   } else {
@@ -468,8 +515,7 @@
     if (!(f2 = fopen(s2->getCString(), "r"))) {
       if (!(f2 = fopen(s2->getCString(), mode))) {
 	delete s2;
-	delete s;
-	return gFalse;
+        continue;
       }
       *name = s2;
       *f = f2;
@@ -479,6 +525,7 @@
     fclose(f2);
     delete s2;
   }
+  fprintf(stderr, "Couldn't create temporary file\n");
   delete s;
   return gFalse;
 #elif defined(VMS) || defined(__EMX__) || defined(ACORN) || defined(MACOS)
@@ -489,7 +536,7 @@
   // with this file name after the tmpnam call and before the fopen
   // call.  I will happily accept fixes to this function for non-Unix
   // OSs.
-  if (!(s = tmpnam(NULL))) {
+  if (!(s = mktmpname(NULL))) {
     return gFalse;
   }
   *name = new GString(s);
@@ -509,7 +556,7 @@
 
   if (ext) {
 #if HAVE_MKSTEMPS
-    if ((s = getenv("TMPDIR"))) {
+    if ((s = getenv("SWFTOOLS_TMP"))) {
       *name = new GString(s);
     } else {
       *name = new GString("/tmp");
@@ -517,7 +564,7 @@
     (*name)->append("/XXXXXX")->append(ext);
     fd = mkstemps((*name)->getCString(), strlen(ext));
 #else
-    if (!(s = tmpnam(NULL))) {
+    if (!(s = mktmpname(NULL))) {
       return gFalse;
     }
     *name = new GString(s);
@@ -526,7 +573,7 @@
 #endif
   } else {
 #if HAVE_MKSTEMP
-    if ((s = getenv("TMPDIR"))) {
+    if ((s = getenv("SWFTOOLS_TMP"))) {
       *name = new GString(s);
     } else {
       *name = new GString("/tmp");
@@ -534,7 +581,7 @@
     (*name)->append("/XXXXXX");
     fd = mkstemp((*name)->getCString());
 #else // HAVE_MKSTEMP
-    if (!(s = tmpnam(NULL))) {
+    if (!(s = mktmpname(NULL))) {
       return gFalse;
     }
     *name = new GString(s);
--- xpdf/gfile.h.orig	2012-06-11 10:35:20.000000000 +0200
+++ xpdf/gfile.h	2012-06-11 11:51:27.000000000 +0200
@@ -58,6 +58,9 @@
 // Get current directory.
 extern GString *getCurrentDir();
 
+/* create a temporary filename */
+char* mktmpname(char*ptr);
+
 // Append a file name to a path string.  <path> may be an empty
 // string, denoting the current directory).  Returns <path>.
 extern GString *appendToPath(GString *path, const char *fileName);
--- xpdf/Gfx.cc.orig	2012-06-11 12:50:19.000000000 +0200
+++ xpdf/Gfx.cc	2012-06-11 12:56:06.000000000 +0200
@@ -3413,8 +3413,11 @@
 			    u, (int)(sizeof(u) / sizeof(Unicode)), &uLen,
 			    &dx, &dy, &originX, &originY);
       dx = dx * state->getFontSize() + state->getCharSpace();
-      if (n == 1 && *p == ' ') {
-	dx += state->getWordSpace();
+      if (n == 1 && (*p == ' ' || *p == 0)) {
+        double w = state->getWordSpace();
+        if (w == 0 && dx == 0)
+          w = state->getFontSize() / 3; // workaround for zero word space
+        dx += w;
       }
       dx *= state->getHorizScaling();
       dy *= state->getFontSize();
@@ -4173,6 +4176,7 @@
     out->beginTransparencyGroup(state, bbox, blendingColorSpace,
 				isolated, knockout, softMask);
   }
+  GfxState *old_state = state;
 
   // set new base matrix
   for (i = 0; i < 6; ++i) {
@@ -4184,6 +4188,9 @@
   display(str, gFalse);
 
   if (softMask || transpGroup) {
+    // restore graphics state
+    while (state != old_state)
+      restoreState();
     out->endTransparencyGroup(state);
   }
 
--- xpdf/GfxFont.cc.orig	2012-06-11 13:02:10.000000000 +0200
+++ xpdf/GfxFont.cc	2012-06-11 13:02:10.000000000 +0200
@@ -1348,6 +1348,10 @@
   return 1;
 }
 
+CharCodeToUnicode* Gfx8BitFont::getCTU() {
+  return ctu;
+}
+
 CharCodeToUnicode *Gfx8BitFont::getToUnicode() {
   ctu->incRefCnt();
   return ctu;
@@ -1856,6 +1860,10 @@
   }
 }
 
+CharCodeToUnicode* GfxCIDFont::getCTU() {
+  return ctu;
+}
+
 int GfxCIDFont::getNextChar(char *s, int len, CharCode *code,
 			    Unicode *u, int uSize, int *uLen,
 			    double *dx, double *dy, double *ox, double *oy) {
--- xpdf/GfxFont.h.orig	2012-06-11 11:58:19.000000000 +0200
+++ xpdf/GfxFont.h	2012-06-11 12:12:16.000000000 +0200
@@ -200,6 +200,7 @@
   virtual int getNextChar(char *s, int len, CharCode *code,
 			  Unicode *u, int uSize, int *uLen,
 			  double *dx, double *dy, double *ox, double *oy) = 0;
+  virtual CharCodeToUnicode* getCTU() = 0;
 
 protected:
 
@@ -239,6 +240,7 @@
   virtual int getNextChar(char *s, int len, CharCode *code,
 			  Unicode *u, int uSize, int *uLen,
 			  double *dx, double *dy, double *ox, double *oy);
+  virtual CharCodeToUnicode* getCTU();
 
   // Return the encoding.
   char **getEncoding() { return enc; }
@@ -247,7 +249,7 @@
   CharCodeToUnicode *getToUnicode();
 
   // Return the character name associated with <code>.
-  char *getCharName(int code) { return enc[code]; }
+  char *getCharName(int code) { return code >= 256 ? 0 : enc[code]; }
 
   // Returns true if the PDF font specified an encoding.
   GBool getHasEncoding() { return hasEncoding; }
@@ -304,6 +306,7 @@
   virtual int getNextChar(char *s, int len, CharCode *code,
 			  Unicode *u, int uSize, int *uLen,
 			  double *dx, double *dy, double *ox, double *oy);
+  virtual CharCodeToUnicode* getCTU();
 
   // Return the writing mode (0=horizontal, 1=vertical).
   virtual int getWMode();
--- xpdf/GfxState.cc.orig	2012-06-11 11:58:19.000000000 +0200
+++ xpdf/GfxState.cc	2012-06-11 11:58:19.000000000 +0200
@@ -21,6 +21,7 @@
 #include "Array.h"
 #include "Page.h"
 #include "GfxState.h"
+#include "cmyk.h"
 
 //------------------------------------------------------------------------
 
@@ -515,6 +516,18 @@
 				- 0.11 * color->c[2] + 0.5));
 }
 
+/*void GfxDeviceCMYKColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {
+  unsigned char r,g,b;
+  float c = color->c[0];
+  float m = color->c[1];
+  float y = color->c[2];
+  float k = color->c[3];
+  convert_cmyk2rgb(c,m,y,k, &r,&g,&b);
+  rgb->r = r/255.0;
+  rgb->g = g/255.0;
+  rgb->b = b/255.0;
+}*/
+
 void GfxDeviceCMYKColorSpace::getRGB(GfxColor *color, GfxRGB *rgb) {
   double c, m, y, k, c1, m1, y1, k1, r, g, b, x;
 
@@ -3299,6 +3312,7 @@
   GfxIndexedColorSpace *indexedCS;
   GfxSeparationColorSpace *sepCS;
   int maxPixel, indexHigh;
+  int maxPixelForAlloc;
   Guchar *indexedLookup;
   Function *sepFunc;
   Object obj;
@@ -3311,6 +3325,7 @@
   // bits per component and color space
   bits = bitsA;
   maxPixel = (1 << bits) - 1;
+  maxPixelForAlloc = (1 << (bits > 8 ? bits : 8));
   colorSpace = colorSpaceA;
 
   // initialize
@@ -3354,7 +3369,7 @@
   // values for each component, i.e., the result of applying the
   // decode mapping to each possible image pixel component value.
   for (k = 0; k < nComps; ++k) {
-    lookup[k] = (GfxColorComp *)gmallocn(maxPixel + 1,
+    lookup[k] = (GfxColorComp *)gmallocn(maxPixelForAlloc + 1,
 					 sizeof(GfxColorComp));
     for (i = 0; i <= maxPixel; ++i) {
       lookup[k][i] = dblToCol(decodeLow[k] +
@@ -3378,7 +3393,7 @@
     indexedLookup = indexedCS->getLookup();
     colorSpace2->getDefaultRanges(x, y, indexHigh);
     for (k = 0; k < nComps2; ++k) {
-      lookup2[k] = (GfxColorComp *)gmallocn(maxPixel + 1,
+      lookup2[k] = (GfxColorComp *)gmallocn(maxPixelForAlloc + 1,
 					    sizeof(GfxColorComp));
     }
     for (i = 0; i <= maxPixel; ++i) {
@@ -3399,7 +3414,7 @@
     nComps2 = colorSpace2->getNComps();
     sepFunc = sepCS->getFunc();
     for (k = 0; k < nComps2; ++k) {
-      lookup2[k] = (GfxColorComp *)gmallocn(maxPixel + 1,
+      lookup2[k] = (GfxColorComp *)gmallocn(maxPixelForAlloc + 1,
 					    sizeof(GfxColorComp));
     }
     for (i = 0; i <= maxPixel; ++i) {
@@ -3969,7 +3984,10 @@
 }
 
 void GfxState::setPath(GfxPath *pathA) {
-  delete path;
+  if (pathA) {
+    if (path)
+      delete path;
+  }
   path = pathA;
 }
 
--- xpdf/GlobalParams.cc.orig	2012-06-11 12:23:56.000000000 +0200
+++ xpdf/GlobalParams.cc	2012-06-11 12:23:56.000000000 +0200
@@ -941,6 +941,29 @@
   int line;
   char buf[512];
 
+  /* extract path */
+  if(fileName) {
+    char* cfgFileName = fileName->getCString();
+    char* pos1 = strrchr(cfgFileName, '/');
+    char* pos2 = strrchr(cfgFileName, '\\');
+    char* p = pos1>pos2?pos1:pos2;
+    int pos = p ? p-cfgFileName : -1;
+    GString* path = new GString(new GString(cfgFileName), 0, (pos < 0 ? strlen(cfgFileName) : pos));
+    if(pos1 >= 0)
+      path->append('/');
+    else if(pos2 >= 0)
+      path->append('\\');
+    else
+#ifdef WIN32
+      path->append('\\');
+#else
+    path->append('/');
+#endif
+    this->path = path;
+  } else {
+    this->path = new GString();
+  }
+
   line = 1;
   while (getLine(buf, sizeof(buf) - 1, f)) {
     parseLine(buf, fileName, line);
@@ -1161,6 +1184,42 @@
   deleteGList(tokens, GString);
 }
 
+static char is_absolute(char* filename)
+{
+  int l = strlen(filename);
+  if (filename[0] == '/' || filename[0] == '\\')
+    return 1;
+  if (l > 2 && filename[1] == ':' && (filename[2] == '\\' || filename[2] == '/'))
+    return 1;
+  return 0;
+}
+
+static GString* qualify_filename(GString* path, GString* filename)
+{
+  GString *fullpath = 0;
+  char *prefix = "/usr/local/share/xpdf/";
+
+  if (!is_absolute(filename->getCString())) {
+    /* relative path */
+    fullpath = path->copy();
+    fullpath->append(filename);
+  } else if (!strncmp(filename->getCString(), prefix, strlen(prefix))) {
+    /* xpdf default path */
+    char* s = strchr(filename->getCString() + strlen(prefix), '/');
+    if (s) {
+      fullpath = path->copy();
+      fullpath->append(s+1);
+    } else {
+      fullpath = filename->copy();
+    }
+  } else {
+    /* absolute path */
+    fullpath = filename->copy();
+  }
+  //printf("%s -%s-> %s\n", filename->getCString(), path->getCString(), fullpath->getCString());
+  return fullpath;
+}
+
 void GlobalParams::parseNameToUnicode(GList *tokens, GString *fileName,
 				      int line) {
   GString *name;
@@ -1176,9 +1235,9 @@
 	  fileName, line);
     return;
   }
-  name = (GString *)tokens->get(1);
+  name = qualify_filename(this->path, (GString *)tokens->get(1));
   if (!(f = openFile(name->getCString(), "r"))) {
-    error(errConfig, -1, "Couldn't open 'nameToUnicode' file '{0:t}'", name);
+    error(errConfig, -1, "Couldn't open 'nameToUnicode' file '{0:t}' using path '{1:t}'", name, this->path);
     return;
   }
   line2 = 1;
@@ -1212,7 +1271,7 @@
   if ((old = (GString *)cidToUnicodes->remove(collection))) {
     delete old;
   }
-  cidToUnicodes->add(collection->copy(), name->copy());
+  cidToUnicodes->add(collection->copy(), qualify_filename(this->path, name));
 }
 
 void GlobalParams::parseUnicodeToUnicode(GList *tokens, GString *fileName,
@@ -1230,7 +1289,7 @@
   if ((old = (GString *)unicodeToUnicodes->remove(font))) {
     delete old;
   }
-  unicodeToUnicodes->add(font->copy(), file->copy());
+  unicodeToUnicodes->add(font->copy(), qualify_filename(this->path, file));
 }
 
 void GlobalParams::parseUnicodeMap(GList *tokens, GString *fileName,
@@ -1247,7 +1306,7 @@
   if ((old = (GString *)unicodeMaps->remove(encodingName))) {
     delete old;
   }
-  unicodeMaps->add(encodingName->copy(), name->copy());
+  unicodeMaps->add(encodingName->copy(), qualify_filename(this->path, name));
 }
 
 void GlobalParams::parseCMapDir(GList *tokens, GString *fileName, int line) {
@@ -1265,28 +1324,37 @@
     list = new GList();
     cMapDirs->add(collection->copy(), list);
   }
-  list->append(dir->copy());
+  list->append(qualify_filename(this->path, dir));
 }
 
 void GlobalParams::parseToUnicodeDir(GList *tokens, GString *fileName,
 				     int line) {
+  GString *dir;
+
   if (tokens->getLength() != 2) {
     error(errConfig, -1,
 	  "Bad 'toUnicodeDir' config file command ({0:t}:{1:d})",
 	  fileName, line);
     return;
   }
-  toUnicodeDirs->append(((GString *)tokens->get(1))->copy());
+
+  dir = (GString *)tokens->get(1);
+
+  toUnicodeDirs->append(qualify_filename(this->path, dir));
 }
 
 void GlobalParams::parseFontFile(GList *tokens, GString *fileName, int line) {
+  GString *file;
+
   if (tokens->getLength() != 3) {
     error(errConfig, -1, "Bad 'fontFile' config file command ({0:t}:{1:d})",
 	  fileName, line);
     return;
   }
+
+  file = (GString *)tokens->get(2);
   fontFiles->add(((GString *)tokens->get(1))->copy(),
-		 ((GString *)tokens->get(2))->copy());
+                 qualify_filename(this->path, file));
 }
 
 void GlobalParams::parseFontDir(GList *tokens, GString *fileName, int line) {
@@ -1300,13 +1368,17 @@
 
 void GlobalParams::parseFontFileCC(GList *tokens, GString *fileName,
 				   int line) {
+  GString *file;
+
   if (tokens->getLength() != 3) {
     error(errConfig, -1, "Bad 'fontFileCC' config file command ({0:t}:{1:d})",
 	  fileName, line);
     return;
   }
+
+  file = (GString *)tokens->get(2);
   ccFontFiles->add(((GString *)tokens->get(1))->copy(),
-		   ((GString *)tokens->get(2))->copy());
+                   qualify_filename(this->path, file));
 }
 
 void GlobalParams::parsePSFile(GList *tokens, GString *fileName, int line) {
--- xpdf/GlobalParams.h.orig	2012-06-11 12:17:07.000000000 +0200
+++ xpdf/GlobalParams.h	2012-06-11 12:22:20.000000000 +0200
@@ -175,7 +175,7 @@
   // file.
   GlobalParams(char *cfgFileName);
 
-  ~GlobalParams();
+  virtual ~GlobalParams();
 
   void setBaseDir(char *dir);
   void setupBaseFonts(char *dir);
@@ -310,6 +310,7 @@
 private:
 
   void createDefaultKeyBindings();
+public:
   void parseFile(GString *fileName, FILE *f);
   void parseNameToUnicode(GList *tokens, GString *fileName, int line);
   void parseCIDToUnicode(GList *tokens, GString *fileName, int line);
@@ -352,6 +353,9 @@
   GBool loadPlugin(char *type, char *name);
 #endif
 
+  //----- config file base path
+  GString *path;
+
   //----- static tables
 
   NameToCharCode *		// mapping from char name to
--- xpdf/gmem.cc.orig	2012-06-11 13:41:14.000000000 +0200
+++ xpdf/gmem.cc	2012-06-11 14:16:37.000000000 +0200
@@ -10,6 +10,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
+#include <stdbool.h>
 #include <string.h>
 #include <limits.h>
 #include "gmem.h"
@@ -47,7 +48,7 @@
 
 #endif /* DEBUG_MEM */
 
-void *gmalloc(int size) GMEM_EXCEP {
+void *gmalloc(int size, bool exit_on_error) GMEM_EXCEP {
 #ifdef DEBUG_MEM
   int size1;
   char *mem;
@@ -60,7 +61,10 @@
     throw GMemException();
 #else
     fprintf(stderr, "Invalid memory allocation size\n");
-    exit(1);
+    if (exit_on_error)
+      exit(1);
+    else
+      return NULL;
 #endif
   }
   if (size == 0) {
@@ -72,7 +76,10 @@
     throw GMemException();
 #else
     fprintf(stderr, "Out of memory\n");
-    exit(1);
+    if (exit_on_error)
+      exit(1);
+    else
+      return NULL;
 #endif
   }
   hdr = (GMemHdr *)mem;
@@ -104,7 +111,10 @@
     throw GMemException();
 #else
     fprintf(stderr, "Invalid memory allocation size\n");
-    exit(1);
+    if (exit_on_error)
+      exit(1);
+    else
+      return NULL;
 #endif
   }
   if (size == 0) {
@@ -115,14 +125,24 @@
     throw GMemException();
 #else
     fprintf(stderr, "Out of memory\n");
-    exit(1);
+    if (exit_on_error)
+      exit(1);
+    else
+      return NULL;
 #endif
   }
   return p;
 #endif
 }
 
-void *grealloc(void *p, int size) GMEM_EXCEP {
+void *gmalloc(int size) GMEM_EXCEP {
+  return gmalloc(size, true);
+}
+void *gmalloc_noexit(int size) GMEM_EXCEP {
+  return gmalloc(size, false);
+}
+
+void *grealloc(void *p, int size, bool exit_on_error) GMEM_EXCEP {
 #ifdef DEBUG_MEM
   GMemHdr *hdr;
   void *q;
@@ -133,7 +153,10 @@
     throw GMemException();
 #else
     fprintf(stderr, "Invalid memory allocation size\n");
-    exit(1);
+    if (exit_on_error)
+      exit(1);
+    else
+      return NULL;
 #endif
   }
   if (size == 0) {
@@ -160,7 +183,10 @@
     throw GMemException();
 #else
     fprintf(stderr, "Invalid memory allocation size\n");
-    exit(1);
+    if (exit_on_error)
+      exit(1);
+    else
+      return NULL;
 #endif
   }
   if (size == 0) {
@@ -179,14 +205,24 @@
     throw GMemException();
 #else
     fprintf(stderr, "Out of memory\n");
-    exit(1);
+    if (exit_on_error)
+      exit(1);
+    else
+      return NULL;
 #endif
   }
   return q;
 #endif
 }
 
-void *gmallocn(int nObjs, int objSize) GMEM_EXCEP {
+void *grealloc(void *p, int size) GMEM_EXCEP {
+  return grealloc(p, size, true);
+}
+void *grealloc_noexit(void *p, int size) GMEM_EXCEP {
+  return grealloc(p, size, false);
+}
+
+void *gmallocn(int nObjs, int objSize, bool exit_on_error) GMEM_EXCEP {
   int n;
 
   if (nObjs == 0) {
@@ -198,13 +234,23 @@
     throw GMemException();
 #else
     fprintf(stderr, "Bogus memory allocation size\n");
-    exit(1);
+    if (exit_on_error)
+      exit(1);
+    else
+      return NULL;
 #endif
   }
   return gmalloc(n);
 }
 
-void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP {
+void *gmallocn(int nObjs, int objSize) GMEM_EXCEP {
+  return gmallocn(nObjs, objSize, true);
+}
+void *gmallocn_noexit(int nObjs, int objSize) GMEM_EXCEP {
+  return gmallocn(nObjs, objSize, false);
+}
+
+void *greallocn(void *p, int nObjs, int objSize, bool exit_on_error) GMEM_EXCEP {
   int n;
 
   if (nObjs == 0) {
@@ -219,12 +265,22 @@
     throw GMemException();
 #else
     fprintf(stderr, "Bogus memory allocation size\n");
-    exit(1);
+    if (exit_on_error)
+      exit(1);
+    else
+      return NULL;
 #endif
   }
   return grealloc(p, n);
 }
 
+void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP {
+  return greallocn(p, nObjs, objSize, true);
+}
+void *greallocn_noexit(void *p, int nObjs, int objSize) GMEM_EXCEP {
+  return greallocn(p, nObjs, objSize, false);
+}
+
 void gfree(void *p) {
 #ifdef DEBUG_MEM
   int size;
--- xpdf/gmem.h.orig	2012-06-11 13:41:14.000000000 +0200
+++ xpdf/gmem.h	2012-06-11 14:17:54.000000000 +0200
@@ -37,12 +37,14 @@
  * returns NULL.
  */
 extern void *gmalloc(int size) GMEM_EXCEP;
+extern void *gmalloc_noexit(int size) GMEM_EXCEP;
 
 /*
  * Same as realloc, but prints error message and exits if realloc()
  * returns NULL.  If <p> is NULL, calls malloc instead of realloc().
  */
 extern void *grealloc(void *p, int size) GMEM_EXCEP;
+extern void *grealloc_noexit(void *p, int size) GMEM_EXCEP;
 
 /*
  * These are similar to gmalloc and grealloc, but take an object count
@@ -52,6 +54,8 @@
  */
 extern void *gmallocn(int nObjs, int objSize) GMEM_EXCEP;
 extern void *greallocn(void *p, int nObjs, int objSize) GMEM_EXCEP;
+extern void *gmallocn_noexit(int nObjs, int objSize) GMEM_EXCEP;
+extern void *greallocn_noexit(void *p, int nObjs, int objSize) GMEM_EXCEP;
 
 /*
  * Same as free, but checks for and ignores NULL pointers.
--- xpdf/JBIG2Stream.cc.orig	2012-06-11 13:41:14.000000000 +0200
+++ xpdf/JBIG2Stream.cc	2012-06-11 13:41:14.000000000 +0200
@@ -6,7 +6,25 @@
 //
 //========================================================================
 
-#include <aconf.h>
+//========================================================================
+//
+// Modified under the Poppler project - http://poppler.freedesktop.org
+//
+// All changes made under the Poppler project to this file are licensed
+// under GPL version 2 or later
+//
+// Copyright (C) 2006 Raj Kumar <rkumar@archive.org>
+// Copyright (C) 2006 Paul Walmsley <paul@booyaka.com>
+// Copyright (C) 2006-2010, 2012 Albert Astals Cid <aacid@kde.org>
+// Copyright (C) 2009 David Benjamin <davidben@mit.edu>
+// Copyright (C) 2011 Edward Jiang <ejiang@google.com>
+//
+// To see a description of the changes please see the Changelog file that
+// came with your tarball or type make ChangeLog if you are building from git
+//
+//========================================================================
+
+#include <config.h>
 
 #ifdef USE_GCC_PRAGMAS
 #pragma implementation
@@ -24,8 +42,8 @@
 
 //------------------------------------------------------------------------
 
-static int contextSize[4] = { 16, 13, 10, 10 };
-static int refContextSize[2] = { 13, 10 };
+static const int contextSize[4] = { 16, 13, 10, 10 };
+static const int refContextSize[2] = { 13, 10 };
 
 //------------------------------------------------------------------------
 // JBIG2HuffmanTable
@@ -42,7 +60,7 @@
   Guint prefix;
 };
 
-JBIG2HuffmanTable huffTableA[] = {
+static JBIG2HuffmanTable huffTableA[] = {
   {     0, 1,  4,              0x000 },
   {    16, 2,  8,              0x002 },
   {   272, 3, 16,              0x006 },
@@ -50,7 +68,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableB[] = {
+static JBIG2HuffmanTable huffTableB[] = {
   {     0, 1,  0,              0x000 },
   {     1, 2,  0,              0x002 },
   {     2, 3,  0,              0x006 },
@@ -61,7 +79,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableC[] = {
+static JBIG2HuffmanTable huffTableC[] = {
   {     0, 1,  0,              0x000 },
   {     1, 2,  0,              0x002 },
   {     2, 3,  0,              0x006 },
@@ -74,7 +92,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableD[] = {
+static JBIG2HuffmanTable huffTableD[] = {
   {     1, 1,  0,              0x000 },
   {     2, 2,  0,              0x002 },
   {     3, 3,  0,              0x006 },
@@ -84,7 +102,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableE[] = {
+static JBIG2HuffmanTable huffTableE[] = {
   {     1, 1,  0,              0x000 },
   {     2, 2,  0,              0x002 },
   {     3, 3,  0,              0x006 },
@@ -96,7 +114,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableF[] = {
+static JBIG2HuffmanTable huffTableF[] = {
   {     0, 2,  7,              0x000 },
   {   128, 3,  7,              0x002 },
   {   256, 3,  8,              0x003 },
@@ -114,7 +132,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableG[] = {
+static JBIG2HuffmanTable huffTableG[] = {
   {  -512, 3,  8,              0x000 },
   {   256, 3,  8,              0x001 },
   {   512, 3,  9,              0x002 },
@@ -133,7 +151,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableH[] = {
+static JBIG2HuffmanTable huffTableH[] = {
   {     0, 2,  1,              0x000 },
   {     0, 2, jbig2HuffmanOOB, 0x001 },
   {     4, 3,  4,              0x004 },
@@ -158,7 +176,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableI[] = {
+static JBIG2HuffmanTable huffTableI[] = {
   {     0, 2, jbig2HuffmanOOB, 0x000 },
   {    -1, 3,  1,              0x002 },
   {     1, 3,  1,              0x003 },
@@ -184,7 +202,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableJ[] = {
+static JBIG2HuffmanTable huffTableJ[] = {
   {    -2, 2,  2,              0x000 },
   {     6, 2,  6,              0x001 },
   {     0, 2, jbig2HuffmanOOB, 0x002 },
@@ -209,7 +227,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableK[] = {
+static JBIG2HuffmanTable huffTableK[] = {
   {     1, 1,  0,              0x000 },
   {     2, 2,  1,              0x002 },
   {     4, 4,  0,              0x00c },
@@ -226,7 +244,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableL[] = {
+static JBIG2HuffmanTable huffTableL[] = {
   {     1, 1,  0,              0x000 },
   {     2, 2,  0,              0x002 },
   {     3, 3,  1,              0x006 },
@@ -243,7 +261,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableM[] = {
+static JBIG2HuffmanTable huffTableM[] = {
   {     1, 1,  0,              0x000 },
   {     2, 3,  0,              0x004 },
   {     7, 3,  3,              0x005 },
@@ -260,7 +278,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableN[] = {
+static JBIG2HuffmanTable huffTableN[] = {
   {     0, 1,  0,              0x000 },
   {    -2, 3,  0,              0x004 },
   {    -1, 3,  0,              0x005 },
@@ -269,7 +287,7 @@
   {     0, 0, jbig2HuffmanEOT, 0     }
 };
 
-JBIG2HuffmanTable huffTableO[] = {
+static JBIG2HuffmanTable huffTableO[] = {
   {     0, 1,  0,              0x000 },
   {    -1, 3,  0,              0x004 },
   {     1, 3,  0,              0x005 },
@@ -308,20 +326,15 @@
   // Sort the table by prefix length and assign prefix values.
   void buildTable(JBIG2HuffmanTable *table, Guint len);
 
-  void resetByteCounter() { byteCounter = 0; }
-  Guint getByteCounter() { return byteCounter; }
-
 private:
 
   Stream *str;
   Guint buf;
   Guint bufLen;
-  Guint byteCounter;
 };
 
 JBIG2HuffmanDecoder::JBIG2HuffmanDecoder() {
   str = NULL;
-  byteCounter = 0;
   reset();
 }
 
@@ -376,12 +389,10 @@
     bufLen = 0;
     while (nLeft >= 8) {
       x = (x << 8) | (str->getChar() & 0xff);
-      ++byteCounter;
       nLeft -= 8;
     }
     if (nLeft > 0) {
       buf = str->getChar();
-      ++byteCounter;
       bufLen = 8 - nLeft;
       x = (x << nLeft) | ((buf >> bufLen) & ((1 << nLeft) - 1));
     }
@@ -392,7 +403,6 @@
 Guint JBIG2HuffmanDecoder::readBit() {
   if (bufLen == 0) {
     buf = str->getChar();
-    ++byteCounter;
     bufLen = 8;
   }
   --bufLen;
@@ -456,8 +466,6 @@
   int getBlackCode();
   int getWhiteCode();
   Guint get24Bits();
-  void resetByteCounter() { byteCounter = 0; }
-  Guint getByteCounter() { return byteCounter; }
   void skipTo(Guint length);
 
 private:
@@ -466,12 +474,10 @@
   Guint buf;
   Guint bufLen;
   Guint nBytesRead;
-  Guint byteCounter;
 };
 
 JBIG2MMRDecoder::JBIG2MMRDecoder() {
   str = NULL;
-  byteCounter = 0;
   reset();
 }
 
@@ -485,13 +491,12 @@
 }
 
 int JBIG2MMRDecoder::get2DCode() {
-  CCITTCode *p;
+  const CCITTCode *p;
 
   if (bufLen == 0) {
     buf = str->getChar() & 0xff;
     bufLen = 8;
     ++nBytesRead;
-    ++byteCounter;
     p = &twoDimTab1[(buf >> 1) & 0x7f];
   } else if (bufLen == 8) {
     p = &twoDimTab1[(buf >> 1) & 0x7f];
@@ -501,13 +506,11 @@
       buf = (buf << 8) | (str->getChar() & 0xff);
       bufLen += 8;
       ++nBytesRead;
-      ++byteCounter;
       p = &twoDimTab1[(buf >> (bufLen - 7)) & 0x7f];
     }
   }
   if (p->bits < 0) {
-    error(errSyntaxError, str->getPos(),
-	  "Bad two dim code in JBIG2 MMR stream");
+    error(errSyntaxError, str->getPos(), "Bad two dim code in JBIG2 MMR stream");
     return EOF;
   }
   bufLen -= p->bits;
@@ -515,14 +518,13 @@
 }
 
 int JBIG2MMRDecoder::getWhiteCode() {
-  CCITTCode *p;
+  const CCITTCode *p;
   Guint code;
 
   if (bufLen == 0) {
     buf = str->getChar() & 0xff;
     bufLen = 8;
     ++nBytesRead;
-    ++byteCounter;
   }
   while (1) {
     if (bufLen >= 11 && ((buf >> (bufLen - 7)) & 0x7f) == 0) {
@@ -550,7 +552,6 @@
     buf = (buf << 8) | (str->getChar() & 0xff);
     bufLen += 8;
     ++nBytesRead;
-    ++byteCounter;
   }
   error(errSyntaxError, str->getPos(), "Bad white code in JBIG2 MMR stream");
   // eat a bit and return a positive number so that the caller doesn't
@@ -560,14 +561,13 @@
 }
 
 int JBIG2MMRDecoder::getBlackCode() {
-  CCITTCode *p;
+  const CCITTCode *p;
   Guint code;
 
   if (bufLen == 0) {
     buf = str->getChar() & 0xff;
     bufLen = 8;
     ++nBytesRead;
-    ++byteCounter;
   }
   while (1) {
     if (bufLen >= 10 && ((buf >> (bufLen - 6)) & 0x3f) == 0) {
@@ -603,7 +603,6 @@
     buf = (buf << 8) | (str->getChar() & 0xff);
     bufLen += 8;
     ++nBytesRead;
-    ++byteCounter;
   }
   error(errSyntaxError, str->getPos(), "Bad black code in JBIG2 MMR stream");
   // eat a bit and return a positive number so that the caller doesn't
@@ -617,7 +616,6 @@
     buf = (buf << 8) | (str->getChar() & 0xff);
     bufLen += 8;
     ++nBytesRead;
-    ++byteCounter;
   }
   return (buf >> (bufLen - 24)) & 0xffffff;
 }
@@ -626,7 +624,6 @@
   while (nBytesRead < length) {
     str->getChar();
     ++nBytesRead;
-    ++byteCounter;
   }
 }
 
@@ -692,6 +689,7 @@
   void combine(JBIG2Bitmap *bitmap, int x, int y, Guint combOp);
   Guchar *getDataPtr() { return data; }
   int getDataSize() { return h * line; }
+  GBool isOk() { return data != NULL; }
 
 private:
 
@@ -707,10 +705,11 @@
   w = wA;
   h = hA;
   line = (wA + 7) >> 3;
+
   if (w <= 0 || h <= 0 || line <= 0 || h >= (INT_MAX - 1) / line) {
-    // force a call to gmalloc(-1), which will throw an exception
-    h = -1;
-    line = 2;
+    error(errSyntaxError, -1, "invalid width/height");
+    data = NULL;
+    return;
   }
   // need to allocate one extra guard byte for use in combine()
   data = (Guchar *)gmalloc(h * line + 1);
@@ -723,10 +722,11 @@
   w = bitmap->w;
   h = bitmap->h;
   line = bitmap->line;
+
   if (w <= 0 || h <= 0 || line <= 0 || h >= (INT_MAX - 1) / line) {
-    // force a call to gmalloc(-1), which will throw an exception
-    h = -1;
-    line = 2;
+    error(errSyntaxError, -1, "invalid width/height");
+    data = NULL;
+    return;
   }
   // need to allocate one extra guard byte for use in combine()
   data = (Guchar *)gmalloc(h * line + 1);
@@ -744,19 +744,27 @@
   Guint xx, yy;
 
   slice = new JBIG2Bitmap(0, wA, hA);
-  slice->clearToZero();
-  for (yy = 0; yy < hA; ++yy) {
-    for (xx = 0; xx < wA; ++xx) {
-      if (getPixel(x + xx, y + yy)) {
-	slice->setPixel(xx, yy);
+  if (slice->isOk()) {
+    slice->clearToZero();
+    for (yy = 0; yy < hA; ++yy) {
+      for (xx = 0; xx < wA; ++xx) {
+        if (getPixel(x + xx, y + yy)) {
+	  slice->setPixel(xx, yy);
+        }
       }
     }
+  } else {
+    delete slice;
+    slice = NULL;
   }
   return slice;
 }
 
 void JBIG2Bitmap::expand(int newH, Guint pixel) {
   if (newH <= h || line <= 0 || newH >= (INT_MAX - 1) / line) {
+    error(errSyntaxError, -1, "invalid width/height");
+    gfree(data);
+    data = NULL;
     return;
   }
   // need to allocate one extra guard byte for use in combine()
@@ -1024,6 +1032,7 @@
   Guint getSize() { return size; }
   void setBitmap(Guint idx, JBIG2Bitmap *bitmap) { bitmaps[idx] = bitmap; }
   JBIG2Bitmap *getBitmap(Guint idx) { return bitmaps[idx]; }
+  GBool isOk() { return bitmaps != NULL; }
   void setGenericRegionStats(JArithmeticDecoderStats *stats)
     { genericRegionStats = stats; }
   void setRefinementRegionStats(JArithmeticDecoderStats *stats)
@@ -1048,6 +1057,7 @@
 
   size = sizeA;
   bitmaps = (JBIG2Bitmap **)gmallocn(size, sizeof(JBIG2Bitmap *));
+  if (!bitmaps) size = 0;
   for (i = 0; i < size; ++i) {
     bitmaps[i] = NULL;
   }
@@ -1059,9 +1069,7 @@
   Guint i;
 
   for (i = 0; i < size; ++i) {
-    if (bitmaps[i]) {
-      delete bitmaps[i];
-    }
+    delete bitmaps[i];
   }
   gfree(bitmaps);
   if (genericRegionStats) {
@@ -1286,6 +1294,7 @@
   Guint segNum, segFlags, segType, page, segLength;
   Guint refFlags, nRefSegs;
   Guint *refSegs;
+  int segDataPos;
   int c1, c2, c3;
   Guint i;
 
@@ -1355,19 +1364,17 @@
       goto eofError2;
     }
 
+    // keep track of the start of the segment data 
+    segDataPos = curStr->getPos();
+
     // check for missing page information segment
     if (!pageBitmap && ((segType >= 4 && segType <= 7) ||
 			(segType >= 20 && segType <= 43))) {
-      error(errSyntaxError, getPos(),
-	    "First JBIG2 segment associated with a page must be a page information segment");
+      error(errSyntaxError, curStr->getPos(), "First JBIG2 segment associated with a page must be a page information segment");
       goto syntaxError;
     }
 
     // read the segment data
-    arithDecoder->resetByteCounter();
-    huffDecoder->resetByteCounter();
-    mmrDecoder->resetByteCounter();
-    byteCounter = 0;
     switch (segType) {
     case 0:
       if (!readSymbolDictSeg(segNum, segLength, refSegs, nRefSegs)) {
@@ -1435,7 +1442,7 @@
       readExtensionSeg(segLength);
       break;
     default:
-      error(errSyntaxError, getPos(), "Unknown segment type in JBIG2 stream");
+      error(errSyntaxError, curStr->getPos(), "Unknown segment type in JBIG2 stream");
       for (i = 0; i < segLength; ++i) {
 	if ((c1 = curStr->getChar()) == EOF) {
 	  goto eofError2;
@@ -1444,30 +1451,45 @@
       break;
     }
 
-    // skip any unused data at the end of the segment
-    // (except for immediate generic region segments which have
-    // 0xffffffff = unspecified length)
-    if (!(segType == 38 && segLength == 0xffffffff)) {
-      byteCounter += arithDecoder->getByteCounter();
-      byteCounter += huffDecoder->getByteCounter();
-      byteCounter += mmrDecoder->getByteCounter();
-      // do a sanity check on byteCounter vs segLength -- if there is
-      // a problem, abort the decode
-      if (byteCounter > segLength ||
-	  segLength - byteCounter > 65536) {
-	error(errSyntaxError, getPos(),
-	      "Invalid segment length in JBIG2 stream");
-	gfree(refSegs);
-	break;
+    // Make sure the segment handler read all of the bytes in the 
+    // segment data, unless this segment is marked as having an
+    // unknown length (section 7.2.7 of the JBIG2 Final Committee Draft)
+
+    if (segLength != 0xffffffff) {
+
+      int segExtraBytes = segDataPos + segLength - curStr->getPos();
+      if (segExtraBytes > 0) {
+
+	// If we didn't read all of the bytes in the segment data,
+	// indicate an error, and throw away the rest of the data.
+	
+	// v.3.1.01.13 of the LuraTech PDF Compressor Server will
+	// sometimes generate an extraneous NULL byte at the end of
+	// arithmetic-coded symbol dictionary segments when numNewSyms
+	// == 0.  Segments like this often occur for blank pages.
+	
+	error(errSyntaxError, curStr->getPos(), "{0:d} extraneous byte{1:s} after segment",
+	      segExtraBytes, (segExtraBytes > 1) ? "s" : "");
+	
+	// Burn through the remaining bytes -- inefficient, but
+	// hopefully we're not doing this much
+	
+	int trash;
+	for (int i = segExtraBytes; i > 0; i--) {
+	  readByte(&trash);
+	}
+	
+      } else if (segExtraBytes < 0) {
+	
+	// If we read more bytes than we should have, according to the 
+	// segment length field, note an error.
+	
+	error(errSyntaxError, curStr->getPos(), "Previous segment handler read too many bytes");
+	
       }
-      while (byteCounter < segLength) {
-	if (curStr->getChar() == EOF) {
-	  break;
-	}
-	++byteCounter;
-      }
-    }
 
+    }
+    
     gfree(refSegs);
   }
 
@@ -1480,7 +1502,7 @@
  eofError2:
   gfree(refSegs);
  eofError1:
-  error(errSyntaxError, getPos(), "Unexpected EOF in JBIG2 stream");
+  error(errSyntaxError, curStr->getPos(), "Unexpected EOF in JBIG2 stream");
 }
 
 GBool JBIG2Stream::readSymbolDictSeg(Guint segNum, Guint length,
@@ -1563,29 +1585,34 @@
   codeTables = new GList();
   numInputSyms = 0;
   for (i = 0; i < nRefSegs; ++i) {
+    // This is need by bug 12014, returning gFalse makes it not crash
+    // but we end up with a empty page while acroread is able to render
+    // part of it
     if ((seg = findSegment(refSegs[i]))) {
       if (seg->getType() == jbig2SegSymbolDict) {
 	j = ((JBIG2SymbolDict *)seg)->getSize();
 	if (numInputSyms > UINT_MAX - j) {
-	  error(errSyntaxError, getPos(),
-		"Too many input symbols in JBIG2 symbol dictionary");
+	  error(errSyntaxError, curStr->getPos(), "Too many input symbols in JBIG2 symbol dictionary");
 	  delete codeTables;
 	  goto eofError;
 	}
 	numInputSyms += j;
       } else if (seg->getType() == jbig2SegCodeTable) {
-	codeTables->append(seg);
+        codeTables->append(seg);
       }
+    } else {
+      delete codeTables;
+      return gFalse;
     }
   }
   if (numInputSyms > UINT_MAX - numNewSyms) {
-    error(errSyntaxError, getPos(),
-	  "Too many input symbols in JBIG2 symbol dictionary");
+    error(errSyntaxError, curStr->getPos(), "Too many input symbols in JBIG2 symbol dictionary");
     delete codeTables;
     goto eofError;
   }
 
-  // compute symbol code length
+  // compute symbol code length, per 6.5.8.2.3
+  //  symCodeLen = ceil( log2( numInputSyms + numNewSyms ) )
   i = numInputSyms + numNewSyms;
   if (i <= 1) {
     symCodeLen = huff ? 1 : 0;
@@ -1602,18 +1629,22 @@
   // get the input symbol bitmaps
   bitmaps = (JBIG2Bitmap **)gmallocn(numInputSyms + numNewSyms,
 				     sizeof(JBIG2Bitmap *));
+  if (!bitmaps) {
+    error(errSyntaxError, curStr->getPos(), "Too many input symbols in JBIG2 symbol dictionary");
+    delete codeTables;
+    goto eofError;
+  }
   for (i = 0; i < numInputSyms + numNewSyms; ++i) {
     bitmaps[i] = NULL;
   }
   k = 0;
   inputSymbolDict = NULL;
   for (i = 0; i < nRefSegs; ++i) {
-    if ((seg = findSegment(refSegs[i]))) {
-      if (seg->getType() == jbig2SegSymbolDict) {
-	inputSymbolDict = (JBIG2SymbolDict *)seg;
-	for (j = 0; j < inputSymbolDict->getSize(); ++j) {
-	  bitmaps[k++] = inputSymbolDict->getBitmap(j);
-	}
+    seg = findSegment(refSegs[i]);
+    if (seg != NULL && seg->getType() == jbig2SegSymbolDict) {
+      inputSymbolDict = (JBIG2SymbolDict *)seg;
+      for (j = 0; j < inputSymbolDict->getSize(); ++j) {
+	bitmaps[k++] = inputSymbolDict->getBitmap(j);
       }
     }
   }
@@ -1705,8 +1736,7 @@
       arithDecoder->decodeInt(&dh, iadhStats);
     }
     if (dh < 0 && (Guint)-dh >= symHeight) {
-      error(errSyntaxError, getPos(),
-	    "Bad delta-height value in JBIG2 symbol dictionary");
+      error(errSyntaxError, curStr->getPos(), "Bad delta-height value in JBIG2 symbol dictionary");
       goto syntaxError;
     }
     symHeight += dh;
@@ -1728,14 +1758,12 @@
 	}
       }
       if (dw < 0 && (Guint)-dw >= symWidth) {
-	error(errSyntaxError, getPos(),
-	      "Bad delta-height value in JBIG2 symbol dictionary");
+	error(errSyntaxError, curStr->getPos(), "Bad delta-height value in JBIG2 symbol dictionary");
 	goto syntaxError;
       }
       symWidth += dw;
       if (i >= numNewSyms) {
-	error(errSyntaxError, getPos(),
-	      "Too many symbols in JBIG2 symbol dictionary");
+	error(errSyntaxError, curStr->getPos(), "Too many symbols in JBIG2 symbol dictionary");
 	goto syntaxError;
       }
 
@@ -1775,8 +1803,7 @@
 	    arithDecoder->decodeInt(&refDY, iardyStats);
 	  }
 	  if (symID >= numInputSyms + i) {
-	    error(errSyntaxError, getPos(),
-		  "Invalid symbol ID in JBIG2 symbol dictionary");
+	    error(errSyntaxError, curStr->getPos(), "Invalid symbol ID in JBIG2 symbol dictionary");
 	    goto syntaxError;
 	  }
 	  refBitmap = bitmaps[symID];
@@ -1820,7 +1847,6 @@
 	    break;
 	  }
 	  *p++ = (Guchar)c;
-	  ++byteCounter;
 	}
       } else {
 	collBitmap = readGenericBitmap(gTrue, totalWidth, symHeight,
@@ -1839,6 +1865,10 @@
 
   // create the symbol dict object
   symbolDict = new JBIG2SymbolDict(segNum, numExSyms);
+  if (!symbolDict->isOk()) {
+    delete symbolDict;
+    goto syntaxError;
+  }
 
   // exported symbol list
   i = j = 0;
@@ -1851,8 +1881,8 @@
     }
     if (i + run > numInputSyms + numNewSyms ||
 	(ex && j + run > numExSyms)) {
-      error(errSyntaxError, getPos(),
-	    "Too many exported symbols in JBIG2 symbol dictionary");
+      error(errSyntaxError, curStr->getPos(), "Too many exported symbols in JBIG2 symbol dictionary");
+      for ( ; j < numExSyms; ++j) symbolDict->setBitmap(j, NULL);
       delete symbolDict;
       goto syntaxError;
     }
@@ -1866,7 +1896,8 @@
     ex = !ex;
   }
   if (j != numExSyms) {
-    error(errSyntaxError, getPos(), "Too few symbols in JBIG2 symbol dictionary");
+    error(errSyntaxError, curStr->getPos(), "Too few symbols in JBIG2 symbol dictionary");
+    for ( ; j < numExSyms; ++j) symbolDict->setBitmap(j, NULL);
     delete symbolDict;
     goto syntaxError;
   }
@@ -1893,7 +1924,7 @@
   return gTrue;
 
  codeTableError:
-  error(errSyntaxError, getPos(), "Missing code table in JBIG2 symbol dictionary");
+  error(errSyntaxError, curStr->getPos(), "Missing code table in JBIG2 symbol dictionary");
   delete codeTables;
 
  syntaxError:
@@ -1909,7 +1940,7 @@
   return gFalse;
 
  eofError:
-  error(errSyntaxError, getPos(), "Unexpected EOF in JBIG2 stream");
+  error(errSyntaxError, curStr->getPos(), "Unexpected EOF in JBIG2 stream");
   return gFalse;
 }
 
@@ -1997,8 +2028,7 @@
 	codeTables->append(seg);
       }
     } else {
-      error(errSyntaxError, getPos(),
-	    "Invalid segment reference in JBIG2 text region");
+      error(errSyntaxError, curStr->getPos(), "Invalid segment reference in JBIG2 text region");
       delete codeTables;
       return;
     }
@@ -2189,18 +2219,20 @@
 
   gfree(syms);
 
-  // combine the region bitmap into the page bitmap
-  if (imm) {
-    if (pageH == 0xffffffff && y + h > curPageH) {
-      pageBitmap->expand(y + h, pageDefPixel);
-    }
-    pageBitmap->combine(bitmap, x, y, extCombOp);
-    delete bitmap;
+  if (bitmap) {
+    // combine the region bitmap into the page bitmap
+    if (imm) {
+      if (pageH == 0xffffffff && y + h > curPageH) {
+        pageBitmap->expand(y + h, pageDefPixel);
+      }
+      pageBitmap->combine(bitmap, x, y, extCombOp);
+      delete bitmap;
 
-  // store the region bitmap
-  } else {
-    bitmap->setSegNum(segNum);
-    segments->append(bitmap);
+    // store the region bitmap
+    } else {
+      bitmap->setSegNum(segNum);
+      segments->append(bitmap);
+    }
   }
 
   // clean up the Huffman decoder
@@ -2211,13 +2243,13 @@
   return;
 
  codeTableError:
-  error(errSyntaxError, getPos(), "Missing code table in JBIG2 text region");
+  error(errSyntaxError, curStr->getPos(), "Missing code table in JBIG2 text region");
   gfree(codeTables);
   delete syms;
   return;
 
  eofError:
-  error(errSyntaxError, getPos(), "Unexpected EOF in JBIG2 stream");
+  error(errSyntaxError, curStr->getPos(), "Unexpected EOF in JBIG2 stream");
   return;
 }
 
@@ -2253,6 +2285,10 @@
 
   // allocate the bitmap
   bitmap = new JBIG2Bitmap(0, w, h);
+  if (!bitmap->isOk()) {
+    delete bitmap;
+    return NULL;
+  }
   if (defPixel) {
     bitmap->clearToOne();
   } else {
@@ -2316,8 +2352,7 @@
       }
 
       if (symID >= (Guint)numSyms) {
-	error(errSyntaxError, getPos(),
-	      "Invalid symbol number in JBIG2 text region");
+	error(errSyntaxError, curStr->getPos(), "Invalid symbol number in JBIG2 text region");
       } else {
 
 	// get the symbol bitmap
@@ -2332,73 +2367,84 @@
 	  ri = 0;
 	}
 	if (ri) {
+	  GBool decodeSuccess;
 	  if (huff) {
-	    huffDecoder->decodeInt(&rdw, huffRDWTable);
-	    huffDecoder->decodeInt(&rdh, huffRDHTable);
-	    huffDecoder->decodeInt(&rdx, huffRDXTable);
-	    huffDecoder->decodeInt(&rdy, huffRDYTable);
-	    huffDecoder->decodeInt(&bmSize, huffRSizeTable);
+	    decodeSuccess = huffDecoder->decodeInt(&rdw, huffRDWTable);
+	    decodeSuccess = decodeSuccess && huffDecoder->decodeInt(&rdh, huffRDHTable);
+	    decodeSuccess = decodeSuccess && huffDecoder->decodeInt(&rdx, huffRDXTable);
+	    decodeSuccess = decodeSuccess && huffDecoder->decodeInt(&rdy, huffRDYTable);
+	    decodeSuccess = decodeSuccess && huffDecoder->decodeInt(&bmSize, huffRSizeTable);
 	    huffDecoder->reset();
 	    arithDecoder->start();
 	  } else {
-	    arithDecoder->decodeInt(&rdw, iardwStats);
-	    arithDecoder->decodeInt(&rdh, iardhStats);
-	    arithDecoder->decodeInt(&rdx, iardxStats);
-	    arithDecoder->decodeInt(&rdy, iardyStats);
-	  }
-	  refDX = ((rdw >= 0) ? rdw : rdw - 1) / 2 + rdx;
-	  refDY = ((rdh >= 0) ? rdh : rdh - 1) / 2 + rdy;
-
-	  symbolBitmap =
-	    readGenericRefinementRegion(rdw + syms[symID]->getWidth(),
-					rdh + syms[symID]->getHeight(),
-					templ, gFalse, syms[symID],
-					refDX, refDY, atx, aty);
+	    decodeSuccess = arithDecoder->decodeInt(&rdw, iardwStats);
+	    decodeSuccess = decodeSuccess && arithDecoder->decodeInt(&rdh, iardhStats);
+	    decodeSuccess = decodeSuccess && arithDecoder->decodeInt(&rdx, iardxStats);
+	    decodeSuccess = decodeSuccess && arithDecoder->decodeInt(&rdy, iardyStats);
+	  }
+	  
+	  if (decodeSuccess && syms[symID])
+	  {
+	    refDX = ((rdw >= 0) ? rdw : rdw - 1) / 2 + rdx;
+	    refDY = ((rdh >= 0) ? rdh : rdh - 1) / 2 + rdy;
+
+	    symbolBitmap =
+	      readGenericRefinementRegion(rdw + syms[symID]->getWidth(),
+					  rdh + syms[symID]->getHeight(),
+					  templ, gFalse, syms[symID],
+					  refDX, refDY, atx, aty);
+	  }
 	  //~ do we need to use the bmSize value here (in Huffman mode)?
 	} else {
 	  symbolBitmap = syms[symID];
 	}
 
-	// combine the symbol bitmap into the region bitmap
-	//~ something is wrong here - refCorner shouldn't degenerate into
-	//~   two cases
-	bw = symbolBitmap->getWidth() - 1;
-	bh = symbolBitmap->getHeight() - 1;
-	if (transposed) {
-	  switch (refCorner) {
-	  case 0: // bottom left
-	    bitmap->combine(symbolBitmap, tt, s, combOp);
-	    break;
-	  case 1: // top left
-	    bitmap->combine(symbolBitmap, tt, s, combOp);
-	    break;
-	  case 2: // bottom right
-	    bitmap->combine(symbolBitmap, tt - bw, s, combOp);
-	    break;
-	  case 3: // top right
-	    bitmap->combine(symbolBitmap, tt - bw, s, combOp);
-	    break;
+	if (symbolBitmap) {
+	  // combine the symbol bitmap into the region bitmap
+	  //~ something is wrong here - refCorner shouldn't degenerate into
+	  //~   two cases
+	  bw = symbolBitmap->getWidth() - 1;
+	  bh = symbolBitmap->getHeight() - 1;
+	  if (transposed) {
+	    switch (refCorner) {
+	    case 0: // bottom left
+	      bitmap->combine(symbolBitmap, tt, s, combOp);
+	      break;
+	    case 1: // top left
+	      bitmap->combine(symbolBitmap, tt, s, combOp);
+	      break;
+	    case 2: // bottom right
+	      bitmap->combine(symbolBitmap, tt - bw, s, combOp);
+	      break;
+	    case 3: // top right
+	      bitmap->combine(symbolBitmap, tt - bw, s, combOp);
+	      break;
+	    }
+	    s += bh;
+	  } else {
+	    switch (refCorner) {
+	    case 0: // bottom left
+	      bitmap->combine(symbolBitmap, s, tt - bh, combOp);
+	      break;
+	    case 1: // top left
+	      bitmap->combine(symbolBitmap, s, tt, combOp);
+	      break;
+	    case 2: // bottom right
+	      bitmap->combine(symbolBitmap, s, tt - bh, combOp);
+	      break;
+	    case 3: // top right
+	      bitmap->combine(symbolBitmap, s, tt, combOp);
+	      break;
+	    }
+	    s += bw;
 	  }
-	  s += bh;
-	} else {
-	  switch (refCorner) {
-	  case 0: // bottom left
-	    bitmap->combine(symbolBitmap, s, tt - bh, combOp);
-	    break;
-	  case 1: // top left
-	    bitmap->combine(symbolBitmap, s, tt, combOp);
-	    break;
-	  case 2: // bottom right
-	    bitmap->combine(symbolBitmap, s, tt - bh, combOp);
-	    break;
-	  case 3: // top right
-	    bitmap->combine(symbolBitmap, s, tt, combOp);
-	    break;
+	  if (ri) {
+	    delete symbolBitmap;
 	  }
-	  s += bw;
-	}
-	if (ri) {
-	  delete symbolBitmap;
+	} else {
+	  // NULL symbolBitmap only happens on error
+	  delete bitmap;
+	  return NULL;
 	}
       }
 
@@ -2454,6 +2500,9 @@
 			     templ, gFalse, gFalse, NULL,
 			     atx, aty, length - 7);
 
+  if (!bitmap)
+    return;
+
   // create the pattern dict object
   patternDict = new JBIG2PatternDict(segNum, grayMax + 1);
 
@@ -2473,7 +2522,7 @@
   return;
 
  eofError:
-  error(errSyntaxError, getPos(), "Unexpected EOF in JBIG2 stream");
+  error(errSyntaxError, curStr->getPos(), "Unexpected EOF in JBIG2 stream");
 }
 
 void JBIG2Stream::readHalftoneRegionSeg(Guint segNum, GBool imm,
@@ -2515,27 +2564,25 @@
     goto eofError;
   }
   if (w == 0 || h == 0 || w >= INT_MAX / h) {
-    error(errSyntaxError, getPos(),
-	  "Bad bitmap size in JBIG2 halftone segment");
+    error(errSyntaxError, curStr->getPos(), "Bad bitmap size in JBIG2 halftone segment");
     return;
   }
   if (gridH == 0 || gridW >= INT_MAX / gridH) {
-    error(errSyntaxError, getPos(), "Bad grid size in JBIG2 halftone segment");
+    error(errSyntaxError, curStr->getPos(), "Bad grid size in JBIG2 halftone segment");
     return;
   }
 
   // get pattern dictionary
   if (nRefSegs != 1) {
-    error(errSyntaxError, getPos(),
-	  "Bad symbol dictionary reference in JBIG2 halftone segment");
+    error(errSyntaxError, curStr->getPos(), "Bad symbol dictionary reference in JBIG2 halftone segment");
     return;
   }
-  if (!(seg = findSegment(refSegs[0])) ||
-      seg->getType() != jbig2SegPatternDict) {
-    error(errSyntaxError, getPos(),
-	  "Bad symbol dictionary reference in JBIG2 halftone segment");
+  seg = findSegment(refSegs[0]);
+  if (seg == NULL || seg->getType() != jbig2SegPatternDict) {
+    error(errSyntaxError, curStr->getPos(), "Bad symbol dictionary reference in JBIG2 halftone segment");
     return;
   }
+
   patternDict = (JBIG2PatternDict *)seg;
   i = patternDict->getSize();
   if (i <= 1) {
@@ -2641,7 +2688,7 @@
   return;
 
  eofError:
-  error(errSyntaxError, getPos(), "Unexpected EOF in JBIG2 stream");
+  error(errSyntaxError, curStr->getPos(), "Unexpected EOF in JBIG2 stream");
 }
 
 void JBIG2Stream::readGenericRegionSeg(Guint segNum, GBool imm,
@@ -2697,6 +2744,8 @@
   // read the bitmap
   bitmap = readGenericBitmap(mmr, w, h, templ, tpgdOn, gFalse,
 			     NULL, atx, aty, mmr ? length - 18 : 0);
+  if (!bitmap)
+    return;
 
   // combine the region bitmap into the page bitmap
   if (imm) {
@@ -2721,15 +2770,14 @@
   return;
 
  eofError:
-  error(errSyntaxError, getPos(), "Unexpected EOF in JBIG2 stream");
+  error(errSyntaxError, curStr->getPos(), "Unexpected EOF in JBIG2 stream");
 }
 
 inline void JBIG2Stream::mmrAddPixels(int a1, int blackPixels,
 				      int *codingLine, int *a0i, int w) {
   if (a1 > codingLine[*a0i]) {
     if (a1 > w) {
-      error(errSyntaxError, getPos(),
-            "JBIG2 MMR row is wrong length ({0:d})", a1);
+      error(errSyntaxError, curStr->getPos(), "JBIG2 MMR row is wrong length ({0:d})", a1);
       a1 = w;
     }
     if ((*a0i & 1) ^ blackPixels) {
@@ -2743,8 +2791,7 @@
 					 int *codingLine, int *a0i, int w) {
   if (a1 > codingLine[*a0i]) {
     if (a1 > w) {
-      error(errSyntaxError, getPos(),
-            "JBIG2 MMR row is wrong length ({0:d})", a1);
+      error(errSyntaxError, curStr->getPos(), "JBIG2 MMR row is wrong length ({0:d})", a1);
       a1 = w;
     }
     if ((*a0i & 1) ^ blackPixels) {
@@ -2753,7 +2800,7 @@
     codingLine[*a0i] = a1;
   } else if (a1 < codingLine[*a0i]) {
     if (a1 < 0) {
-      error(errSyntaxError, getPos(), "Invalid JBIG2 MMR code");
+      error(errSyntaxError, curStr->getPos(), "Invalid JBIG2 MMR code");
       a1 = 0;
     }
     while (*a0i > 0 && a1 <= codingLine[*a0i - 1]) {
@@ -2781,8 +2828,11 @@
   Guchar mask;
   int x, y, x0, x1, a0i, b1i, blackPixels, pix, i;
 
-
   bitmap = new JBIG2Bitmap(0, w, h);
+  if (!bitmap->isOk()) {
+    delete bitmap;
+    return NULL;
+  }
   bitmap->clearToZero();
 
   //----- MMR decode
@@ -2791,7 +2841,7 @@
 
     mmrDecoder->reset();
     if (w > INT_MAX - 2) {
-      error(errSyntaxError, getPos(), "Bad width in JBIG2 generic bitmap");
+      error(errSyntaxError, curStr->getPos(), "Bad width in JBIG2 generic bitmap");
       // force a call to gmalloc(-1), which will throw an exception
       w = -3;
     }
@@ -2801,7 +2851,7 @@
     // ---> max refLine size = w + 2
     codingLine = (int *)gmallocn(w + 1, sizeof(int));
     refLine = (int *)gmallocn(w + 2, sizeof(int));
-    codingLine[0] = w;
+    for (i = 0; i < w + 1; ++i) codingLine[i] = w;
 
     for (y = 0; y < h; ++y) {
 
@@ -2945,8 +2995,7 @@
           mmrAddPixels(w, 0, codingLine, &a0i, w);
           break;
 	default:
-	  error(errSyntaxError, getPos(),
-		"Illegal code in JBIG2 MMR bitmap data");
+	  error(errSyntaxError, curStr->getPos(), "Illegal code in JBIG2 MMR bitmap data");
           mmrAddPixels(w, 0, codingLine, &a0i, w);
 	  break;
 	}
@@ -2969,8 +3018,7 @@
       mmrDecoder->skipTo(mmrDataLength);
     } else {
       if (mmrDecoder->get24Bits() != 0x001001) {
-	error(errSyntaxError, getPos(),
-	      "Missing EOFB in JBIG2 MMR bitmap data");
+	error(errSyntaxError, curStr->getPos(), "Missing EOFB in JBIG2 MMR bitmap data");
       }
     }
 
@@ -3562,15 +3610,13 @@
 
   // get referenced bitmap
   if (nRefSegs > 1) {
-    error(errSyntaxError, getPos(),
-	  "Bad reference in JBIG2 generic refinement segment");
+    error(errSyntaxError, curStr->getPos(), "Bad reference in JBIG2 generic refinement segment");
     return;
   }
   if (nRefSegs == 1) {
-    if (!(seg = findSegment(refSegs[0])) ||
-	seg->getType() != jbig2SegBitmap) {
-      error(errSyntaxError, getPos(),
-	    "Bad bitmap reference in JBIG2 generic refinement segment");
+    seg = findSegment(refSegs[0]);
+    if (seg == NULL || seg->getType() != jbig2SegBitmap) {
+      error(errSyntaxError, curStr->getPos(), "Bad bitmap reference in JBIG2 generic refinement segment");
       return;
     }
     refBitmap = (JBIG2Bitmap *)seg;
@@ -3593,8 +3639,12 @@
 
   // store the region bitmap
   } else {
-    bitmap->setSegNum(segNum);
-    segments->append(bitmap);
+    if (bitmap) {
+      bitmap->setSegNum(segNum);
+      segments->append(bitmap);
+    } else {
+      error(errSyntaxError, curStr->getPos(), "readGenericRefinementRegionSeg with null bitmap");
+    }
   }
 
   // delete the referenced bitmap
@@ -3607,7 +3657,7 @@
   return;
 
  eofError:
-  error(errSyntaxError, getPos(), "Unexpected EOF in JBIG2 stream");
+  error(errSyntaxError, curStr->getPos(), "Unexpected EOF in JBIG2 stream");
 }
 
 JBIG2Bitmap *JBIG2Stream::readGenericRefinementRegion(int w, int h,
@@ -3618,11 +3668,24 @@
   JBIG2Bitmap *bitmap;
   GBool ltp;
   Guint ltpCX, cx, cx0, cx2, cx3, cx4, tpgrCX0, tpgrCX1, tpgrCX2;
-  JBIG2BitmapPtr cxPtr0, cxPtr1, cxPtr2, cxPtr3, cxPtr4, cxPtr5, cxPtr6;
-  JBIG2BitmapPtr tpgrCXPtr0, tpgrCXPtr1, tpgrCXPtr2;
+  JBIG2BitmapPtr cxPtr0 = {0};
+  JBIG2BitmapPtr cxPtr1 = {0};
+  JBIG2BitmapPtr cxPtr2 = {0};
+  JBIG2BitmapPtr cxPtr3 = {0};
+  JBIG2BitmapPtr cxPtr4 = {0};
+  JBIG2BitmapPtr cxPtr5 = {0};
+  JBIG2BitmapPtr cxPtr6 = {0};
+  JBIG2BitmapPtr tpgrCXPtr0 = {0};
+  JBIG2BitmapPtr tpgrCXPtr1 = {0};
+  JBIG2BitmapPtr tpgrCXPtr2 = {0};
   int x, y, pix;
 
   bitmap = new JBIG2Bitmap(0, w, h);
+  if (!bitmap->isOk())
+  {
+    delete bitmap;
+    return NULL;
+  }
   bitmap->clearToZero();
 
   // set up the typical row context
@@ -3807,6 +3870,12 @@
   }
   pageBitmap = new JBIG2Bitmap(0, pageW, curPageH);
 
+  if (!pageBitmap->isOk()) {
+    delete pageBitmap;
+    pageBitmap = NULL;
+    return;
+  }
+  
   // default pixel value
   if (pageDefPixel) {
     pageBitmap->clearToOne();
@@ -3817,7 +3886,7 @@
   return;
 
  eofError:
-  error(errSyntaxError, getPos(), "Unexpected EOF in JBIG2 stream");
+  error(errSyntaxError, curStr->getPos(), "Unexpected EOF in JBIG2 stream");
 }
 
 void JBIG2Stream::readEndOfStripeSeg(Guint length) {
@@ -3828,7 +3897,6 @@
     if (curStr->getChar() == EOF) {
       break;
     }
-    ++byteCounter;
   }
 }
 
@@ -3840,7 +3908,6 @@
     if (curStr->getChar() == EOF) {
       break;
     }
-    ++byteCounter;
   }
 }
 
@@ -3905,7 +3972,7 @@
   return;
 
  eofError:
-  error(errSyntaxError, getPos(), "Unexpected EOF in JBIG2 stream");
+  error(errSyntaxError, curStr->getPos(), "Unexpected EOF in JBIG2 stream");
 }
 
 void JBIG2Stream::readExtensionSeg(Guint length) {
@@ -3916,7 +3983,6 @@
     if (curStr->getChar() == EOF) {
       break;
     }
-    ++byteCounter;
   }
 }
 
@@ -4031,7 +4097,6 @@
   if ((c0 = curStr->getChar()) == EOF) {
     return gFalse;
   }
-  ++byteCounter;
   *x = (Guint)c0;
   return gTrue;
 }
@@ -4042,7 +4107,6 @@
   if ((c0 = curStr->getChar()) == EOF) {
     return gFalse;
   }
-  ++byteCounter;
   *x = c0;
   if (c0 & 0x80) {
     *x |= -1 - 0xff;
@@ -4057,7 +4121,6 @@
       (c1 = curStr->getChar()) == EOF) {
     return gFalse;
   }
-  byteCounter += 2;
   *x = (Guint)((c0 << 8) | c1);
   return gTrue;
 }
@@ -4071,7 +4134,6 @@
       (c3 = curStr->getChar()) == EOF) {
     return gFalse;
   }
-  byteCounter += 4;
   *x = (Guint)((c0 << 24) | (c1 << 16) | (c2 << 8) | c3);
   return gTrue;
 }
@@ -4085,7 +4147,6 @@
       (c3 = curStr->getChar()) == EOF) {
     return gFalse;
   }
-  byteCounter += 4;
   *x = ((c0 << 24) | (c1 << 16) | (c2 << 8) | c3);
   if (c0 & 0x80) {
     *x |= -1 - (int)0xffffffff;
--- xpdf/JPXStream.cc.orig	2012-06-11 13:38:40.000000000 +0200
+++ xpdf/JPXStream.cc	2012-06-11 13:40:14.000000000 +0200
@@ -238,6 +238,12 @@
   haveCompMap = gFalse;
   haveChannelDefn = gFalse;
 
+  img.xSize = 0;
+  img.ySize = 0;
+  img.xOffset = 0;
+  img.yOffset = 0;
+  curX = 0;
+  curY = 0;
   img.tiles = NULL;
   bitBuf = 0;
   bitBufLen = 0;
--- xpdf/Lexer.cc.orig	2012-06-11 13:38:40.000000000 +0200
+++ xpdf/Lexer.cc	2012-06-11 13:38:40.000000000 +0200
@@ -75,6 +75,8 @@
   }
 }
 
+static int illegalChars = 0;
+
 Lexer::~Lexer() {
   if (!curStr.isNone()) {
     curStr.streamClose();
@@ -83,6 +85,9 @@
   if (freeArray) {
     delete streams;
   }
+  if (illegalChars)
+    error(errSyntaxWarning, 0, "Illegal characters in hex string ({0:d})", illegalChars);
+  illegalChars = 0;
 }
 
 int Lexer::getChar() {
@@ -333,7 +338,8 @@
 	} else if (c2 >= 'a' && c2 <= 'f') {
 	  c += c2 - 'a' + 10;
 	} else {
-	  error(errSyntaxError, getPos(), "Illegal digit in hex char in name");
+          illegalChars++;
+	  //error(errSyntaxError, getPos(), "Illegal digit in hex char in name");
 	}
       }
      notEscChar:
@@ -399,9 +405,10 @@
 	    c2 += c - 'A' + 10;
 	  else if (c >= 'a' && c <= 'f')
 	    c2 += c - 'a' + 10;
-	  else
-	    error(errSyntaxError, getPos(),
-		  "Illegal character <{0:02x}> in hex string", c);
+	  else {
+            illegalChars++;
+	    //error(errSyntaxError, getPos(), "Illegal character <{0:02x}> in hex string", c);
+          }
 	  if (++m == 2) {
 	    if (n == tokBufSize) {
 	      if (!s)
@@ -437,7 +444,8 @@
       tokBuf[2] = '\0';
       obj->initCmd(tokBuf);
     } else {
-      error(errSyntaxError, getPos(), "Illegal character '>'");
+      illegalChars++;
+      //error(errSyntaxError, getPos(), "Illegal character '>'");
       obj->initError();
     }
     break;
@@ -446,7 +454,8 @@
   case ')':
   case '{':
   case '}':
-    error(errSyntaxError, getPos(), "Illegal character '{0:c}'", c);
+    //error(errSyntaxError, getPos(), "Illegal character '{0:c}'", c);
+    illegalChars++;
     obj->initError();
     break;
 
--- xpdf/Link.cc.orig	2012-06-11 10:35:20.000000000 +0200
+++ xpdf/Link.cc	2012-06-11 11:01:23.000000000 +0200
@@ -450,7 +450,7 @@
 
   // error
   } else {
-    error(errSyntaxWarning, -1, "Illegal annotation destination");
+    error(errSyntaxWarning, -1, "Illegal annotation destination {0:d}", destObj->getType());
   }
 }
 
@@ -488,7 +488,7 @@
 
   // error
   } else {
-    error(errSyntaxWarning, -1, "Illegal annotation destination");
+    error(errSyntaxWarning, -1, "Illegal annotation destination {0:d}", destObj->getType());
   }
 }
 
--- xpdf/pdftoppm.cc.orig	2012-06-11 14:35:05.000000000 +0200
+++ xpdf/pdftoppm.cc	2012-06-11 14:37:32.000000000 +0200
@@ -7,7 +7,11 @@
 //========================================================================
 
 #include <aconf.h>
+#include <time.h>
+#include <unistd.h>
+#include <sys/types.h>
 #include <stdio.h>
+#include <stdlib.h>
 #include "parseargs.h"
 #include "gmem.h"
 #include "GString.h"
@@ -93,6 +97,13 @@
 
   exitCode = 99;
 
+#ifdef HAVE_LRAND48
+  srand48(time(0) * getpid());
+#endif
+#ifdef HAVE_RAND
+  srand(time(0) * getpid());
+#endif
+
   // parse args
   ok = parseArgs(argDesc, &argc, argv);
   if (mono && gray) {
--- xpdf/SplashFont.cc.orig	2012-06-11 14:35:05.000000000 +0200
+++ xpdf/SplashFont.cc	2012-06-11 14:35:05.000000000 +0200
@@ -55,6 +55,10 @@
   cacheTags = NULL;
 
   xMin = yMin = xMax = yMax = 0;
+
+  last_advance = -1;
+  ascender = -1;
+  descender = -1;
 }
 
 void SplashFont::initCache() {
@@ -76,11 +80,15 @@
        cacheSets > 1 &&
 	 cacheSets * cacheAssoc * glyphSize > splashFontCacheSize;
        cacheSets >>= 1) ;
-  cache = (Guchar *)gmallocn(cacheSets * cacheAssoc, glyphSize);
-  cacheTags = (SplashFontCacheTag *)gmallocn(cacheSets * cacheAssoc,
-					     sizeof(SplashFontCacheTag));
-  for (i = 0; i < cacheSets * cacheAssoc; ++i) {
-    cacheTags[i].mru = i & (cacheAssoc - 1);
+  cache = (Guchar *)gmallocn_noexit(cacheSets * cacheAssoc, glyphSize);
+  if (cache) {
+    cacheTags = (SplashFontCacheTag *)gmallocn(cacheSets * cacheAssoc,
+                                               sizeof(SplashFontCacheTag));
+    for (i = 0; i < cacheSets * cacheAssoc; ++i) {
+      cacheTags[i].mru = i & (cacheAssoc - 1);
+    }
+  } else {
+    cacheAssoc = 0;
   }
 }
 
--- xpdf/SplashFontFile.cc.orig	2012-06-11 13:41:14.000000000 +0200
+++ xpdf/SplashFontFile.cc	2012-06-11 13:41:14.000000000 +0200
@@ -11,9 +11,7 @@
 #endif
 
 #include <stdio.h>
-#ifndef WIN32
-#  include <unistd.h>
-#endif
+#include <unistd.h>
 #include "GString.h"
 #include "SplashFontFile.h"
 #include "SplashFontFileID.h"
--- xpdf/SplashFont.h.orig	2012-06-11 11:58:19.000000000 +0200
+++ xpdf/SplashFont.h	2012-06-11 12:08:06.000000000 +0200
@@ -73,6 +73,9 @@
   virtual GBool makeGlyph(int c, int xFrac, int yFrac,
 			  SplashGlyphBitmap *bitmap) = 0;
 
+  // return the number of characters in this font
+  virtual int getNumChars() = 0;
+
   // Return the path for a glyph.
   virtual SplashPath *getGlyphPath(int c) = 0;
 
@@ -83,6 +86,9 @@
   void getBBox(int *xMinA, int *yMinA, int *xMaxA, int *yMaxA)
     { *xMinA = xMin; *yMinA = yMin; *xMaxA = xMax; *yMaxA = yMax; }
 
+  double ascender;
+  double descender;
+  double last_advance; //set after getGlyphPath()
 protected:
 
   SplashFontFile *fontFile;
--- xpdf/SplashFTFont.cc.orig	2012-06-11 12:23:56.000000000 +0200
+++ xpdf/SplashFTFont.cc	2012-06-11 12:41:10.000000000 +0200
@@ -61,6 +61,10 @@
   if (FT_Set_Pixel_Sizes(face, 0, size)) {
     return;
   }
+
+  this->ascender = face->ascender;
+  this->descender = face->descender;
+
   // if the textMat values are too small, FreeType's fixed point
   // arithmetic doesn't work so well
   textScale = splashDist(0, 0, textMat[2], textMat[3]) / size;
@@ -300,6 +304,12 @@
   GBool needClose;
 };
 
+int SplashFTFont::getNumChars()
+{
+  SplashFTFontFile* ff = (SplashFTFontFile *)fontFile;
+  return ff->face->num_glyphs;
+}
+
 SplashPath *SplashFTFont::getGlyphPath(int c) {
   static FT_Outline_Funcs outlineFuncs = {
 #if FREETYPE_MINOR <= 1
@@ -321,6 +331,8 @@
   FT_UInt gid;
   FT_Glyph glyph;
 
+  this->last_advance = -1;
+
   ff = (SplashFTFontFile *)fontFile;
   ff->face->size = sizeObj;
   FT_Set_Transform(ff->face, &textMatrix, NULL);
@@ -334,17 +346,26 @@
     // skip the TrueType notdef glyph
     return NULL;
   }
-  if (FT_Load_Glyph(ff->face, gid, FT_LOAD_NO_BITMAP)) {
-    return NULL;
+  int error = 0;
+  if ((error = FT_Load_Glyph(ff->face, gid, FT_LOAD_NO_BITMAP))) {
+    if ((error = FT_Load_Glyph(ff->face, gid, FT_LOAD_NO_BITMAP|FT_LOAD_NO_HINTING))) {
+      fprintf(stderr, "Truetype wasn't able to load glyph %d, error %d\n", gid, error);
+      return NULL;
+    }
   }
   if (FT_Get_Glyph(slot, &glyph)) {
     return NULL;
   }
+  this->last_advance = glyph->advance.x / 65536.0;
+
   path.path = new SplashPath();
   path.textScale = textScale;
   path.needClose = gFalse;
-  FT_Outline_Decompose(&((FT_OutlineGlyph)glyph)->outline,
-		       &outlineFuncs, &path);
+  error = FT_Outline_Decompose(&((FT_OutlineGlyph)glyph)->outline,
+                               &outlineFuncs, &path);
+  if (error) {
+    fprintf(stderr, "Truetype wasn't able to read glyph %d, error %d\n", gid, error);
+  }
   if (path.needClose) {
     path.path->close();
   }
--- xpdf/SplashFTFont.h.orig	2012-06-11 12:57:26.000000000 +0200
+++ xpdf/SplashFTFont.h	2012-06-11 12:57:26.000000000 +0200
@@ -42,6 +42,9 @@
   virtual GBool makeGlyph(int c, int xFrac, int yFrac,
 			  SplashGlyphBitmap *bitmap);
 
+  // return the number of characters in this font
+  virtual int getNumChars();
+
   // Return the path for a glyph.
   virtual SplashPath *getGlyphPath(int c);
 
--- xpdf/SplashOutputDev.cc.orig	2012-06-11 11:58:19.000000000 +0200
+++ xpdf/SplashOutputDev.cc	2012-06-11 12:05:38.000000000 +0200
@@ -13,6 +13,7 @@
 #endif
 
 #include <string.h>
+#include <unistd.h>
 #include <math.h>
 #include <limits.h>
 #include "gfile.h"
@@ -3070,10 +3071,11 @@
 
   softMask = new SplashBitmap(bitmap->getWidth(), bitmap->getHeight(),
 			      1, splashModeMono8, gFalse);
-  memset(softMask->getDataPtr(), 0,
+  memset(softMask->getDataPtr(), 0x00,
 	 softMask->getRowSize() * softMask->getHeight());
   if (tx < softMask->getWidth() && ty < softMask->getHeight()) {
     p = softMask->getDataPtr() + ty * softMask->getRowSize() + tx;
+    if (tx < softMask->getWidth() && ty < softMask->getHeight())
     for (y = 0; y < tBitmap->getHeight(); ++y) {
       for (x = 0; x < tBitmap->getWidth(); ++x) {
 	if (alpha) {
--- xpdf/SplashOutputDev.h.orig	2012-06-11 14:18:57.000000000 +0200
+++ xpdf/SplashOutputDev.h	2012-06-11 14:21:10.000000000 +0200
@@ -223,6 +223,11 @@
   virtual void setInShading(GBool sh);
 #endif
 
+  void doUpdateFont(GfxState *state);
+  GBool needFontUpdate;               // set when the font needs to be updated
+
+  SplashPath *convertPath(GfxState *state, GfxPath *path,
+                          GBool dropEmptySubpaths);
 private:
 
   void setupScreenParams(double hDPI, double vDPI);
@@ -233,9 +238,6 @@
 #endif
   void setOverprintMask(GfxColorSpace *colorSpace, GBool overprintFlag,
 			int overprintMode, GfxColor *singleColor);
-  SplashPath *convertPath(GfxState *state, GfxPath *path,
-			  GBool dropEmptySubpaths);
-  void doUpdateFont(GfxState *state);
   void drawType3Glyph(GfxState *state, T3FontCache *t3Font,
 		      T3FontCacheTag *tag, Guchar *data);
   static GBool imageMaskSrc(void *data, SplashColorPtr line);
@@ -271,7 +273,6 @@
   GBool haveT3Dx;		// set after seeing a d0/d1 operator
 
   SplashFont *font;		// current font
-  GBool needFontUpdate;		// set when the font needs to be updated
   SplashPath *textClipPath;	// clipping path built with text object
 
   SplashTransparencyGroup *	// transparency group stack
--- xpdf/Stream.cc.orig	2012-06-11 14:18:57.000000000 +0200
+++ xpdf/Stream.cc	2012-06-11 14:18:57.000000000 +0200
@@ -18,6 +18,8 @@
 #include <limits.h>
 #ifndef WIN32
 #include <unistd.h>
+#else
+extern "C" int unlink(char *filename);
 #endif
 #include <string.h>
 #include <ctype.h>
@@ -2646,6 +2648,9 @@
   // check for an EOB run
   if (eobRun > 0) {
     while (i <= scanInfo.lastCoeff) {
+      if (i >= 64) {
+        return gFalse;
+      }
       j = dctZigZag[i++];
       if (data[j] != 0) {
 	if ((bit = readBit()) == EOF) {
@@ -2670,6 +2675,9 @@
     if (c == 0xf0) {
       k = 0;
       while (k < 16 && i <= scanInfo.lastCoeff) {
+        if (i >= 64) {
+          return gFalse;
+        }
 	j = dctZigZag[i++];
 	if (data[j] == 0) {
 	  ++k;
@@ -2695,6 +2703,9 @@
       }
       eobRun += 1 << j;
       while (i <= scanInfo.lastCoeff) {
+        if (i >= 64) {
+          return gFalse;
+        }
 	j = dctZigZag[i++];
 	if (data[j] != 0) {
 	  if ((bit = readBit()) == EOF) {
@@ -2717,6 +2728,9 @@
       }
       j = 0; // make gcc happy
       for (k = 0; k <= run && i <= scanInfo.lastCoeff; ++k) {
+        if (i >= 64) {
+          return gFalse;
+        }
 	j = dctZigZag[i++];
 	while (data[j] != 0 && i <= scanInfo.lastCoeff) {
 	  if ((bit = readBit()) == EOF) {
@@ -2725,6 +2739,9 @@
 	  if (bit) {
 	    data[j] += 1 << scanInfo.al;
 	  }
+          if (i >= 64) {
+            return gFalse;
+          }
 	  j = dctZigZag[i++];
 	}
       }
